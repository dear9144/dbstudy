/*
        셀프 조인
        1. 하나의 테이블에 PK와 FK가 모두 있는 경우에 사용되는 조인인다
        2. 동일한 테이블을 조인하기 때문에 별명을 다르게 지정해서 조인한다 
        3. 문법은 기본적으로 내부 조인과 동일하다 
*/

--모든 사원들의 EMPLOYEE_ID, FIRST_NAME, LAST_NAME, MANAGER의 FIRST_NAME 을 조회하시오 
-- 1:M 관계 파악
-- PK           FK
-- EMPLOYEE_ID  MANAGER_ID


-- 조인 조건 파악
-- 사원 테이블 E           -  매니저 테이블 M
-- 사원들의 매니저번호     -  매니저의 사원번호 
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME  -- 각 사원들의 정보 ,   M.FIRST_NAME                              -- 매니저 정보 (사원번호) 
  FROM  EMPLOYEES E LEFT OUTER JOIN EMPLOYEES M
    ON  E.MANAGER_ID = M.EMPLOYEE_ID;
 -- ORDER BY E.EMPLOYEE_ID;
 
--각 사원들 중에서 매니저보다 먼저 입사한 사원들 조회하시오 
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE AS 입사일자
    ,  M.EMPLOYEE_ID, M.FIRST_NAME, M.HIRE_DATE AS 매니저입사일자
 FROM EMPLOYEES E INNER JOIN EMPLOYEES M
    ON E.MANAGER_ID = M.EMPLOYEE_ID
WHERE TO_DATE(E.HIRE_DATE,'YY/MM/DD') < TO_DATE(M.HIRE_DATE,'YY/MM/DD')--옛날이면 더 값이 작은 것 
ORDER BY
    E.EMPLOYEE_ID; -- 오름차순 위한 
    
    
    
-- PK, FK가 아닌 일반 칼럼을 이용한 셀프 조인
-- 동일한 부서에서 근무하는 사원들을 조인하기 위해 DEPARTMENT_ID로 JOIN조건을 생성해보도록 하자 
--사원(나)             --사원(다른 사람)
-- EMPLOYEES ME        EMPLOYEES YOU
-- 문제 . 같은 부서에 근무하는 사원 중에서 나보다 SALATRY가 높은 사원 정보를 조회하시오 
SELECT ME.EMPLOYEE_ID, ME.FIRST_NAME, ME.SALARY AS 내급여 
,      YOU.FIRST_NAME, YOU.SALARY AS 너급여
,      ME.DEPARTMENT_ID, YOU.DEPARTMENT_ID
    FROM EMPLOYEES ME INNER JOIN EMPLOYEES YOU
ON ME.DEPARTMENT_ID = YOU.DEPARTMENT_ID
WHERE ME.SALARY < YOU.SALARY
ORDER BY ME.EMPLOYEE_ID;


--조인 연습

--1. LOCATION_ID 1700인 부서에 근무하는 사원들의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID을 조회하는 문제
--  EMPLOYEES :EMPLOYEE_ID, FIRST_NAME
--  DEAPRTMENTS :DEPARTMENT_NAME
SELECT E.EMPLOYEE_ID , E.FIRST_NAME, Y.DEPARTMENT_NAME
    FROM EMPLOYEES E INNER JOIN DEPARTMENTS Y 
   ON E.EMPLOYEE_ID = Y.DEPARTMENT_ID
WHERE Y.LOCATION_ID = 1700; --'1700' 오라클은 이렇게 써도 숫자로 바꿔줌 
--JAVA로 치면 저게 String인데 INTEGER PARSHING을 해야 하는데 오라클은 자동으로 해준다는 뜻
SELECT E.EMPLOYEE_ID , E.FIRST_NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E , DEPARTMENTS D 
   WHERE E.EMPLOYEE_ID = D.DEPARTMENT_ID AND 
         D.LOCATION_ID = 1700;
-- 2. DEPARTMENT_NAME이 'Executive'인 부서에 근무하는 사원들의 EMPLOYEE_ID, FIRST_NAME을 조회하시오.
-- 1) 표준 문법
SELECT E.EMPLOYEE_ID , E.FIRST_NAME
    FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
    ON E.EMPLOYEES = J.GOB_HISTORY AND
           D. DEPARTMENT_NAME = 'Executive';

-- 2) 오라클 문법


--3 3개짜리 JOIN 
--모든 사원들의,EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME, CITY
-- LOCATIONS - DEPARTMENTS 관계를 먼저 준다 그럼 그 둘을 하나로 합쳐졌다 생각 
-- 그런 후 EMPLOYEES를 나중에 연관 짓는다 
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_NAME, L.CITY
    FROM LOCATIONS L INNER JOIN DEPARTMENTS D
    ON L.LOCATION_ID = D.LOCATION_ID INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;
    
    
    
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_NAME, L.CITY
    FROM LOCATIONS L , DEPARTMENTS D , EMPLOYEES E
    WHERE L.LOCATION_ID = D.LOCATION_ID 
    AND D.DEPARTMENT_ID = E.DEPARTMENT_ID;
    

--4. 부서별 DEPARTMENT_NAME과 사원 수 , 평균 연봉을 조회하시오
-- GROUP BY JOIN 함께 사용해 보기
-- 부서별 DEPARTMENT_ID과 사원 수와 평균 연봉을 조회하시오.
-- SELECT DEPARTMENT_ID,COUNT(*),AVG(SALARY)

SELECT D.DEPARTMENT_NAME ,D.DEPARTMENT_ID, COUNT(*),AVG(E.SALARY) 
    FROM DEPARTMENTS D INNER JOIN EMPLOYEE_TBL E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME ,D.DEPARTMENT_ID;
    
